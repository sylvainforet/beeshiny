// this tutorial uses a vector of 0s and 1s to describe each image


#include <stdlib.h>
#include "opencv2/opencv.hpp"
#include "opencv2/core/core.hpp"
#include "opencv2/highgui/highgui.hpp"
#include <string.h>
#include <fstream>
usingnamespacestd;
 
voidscaleDownImage(cv::Mat &originalImg,cv::Mat &scaledDownImage )
{      
    for(intx=0;x<16;x++)
    {  
        for(inty=0;y<16 ;y++)
        {
            intyd =ceil((float)(y*originalImg.cols/16));
            intxd = ceil((float)(x*originalImg.rows/16));
            scaledDownImage.at<uchar>(x,y) = originalImg.at<uchar>(xd,yd);
 
        }
    }
}
voidcropImage(cv::Mat &originalImage,cv::Mat &croppedImage)
{
    introw = originalImage.rows;
    intcol = originalImage.cols;
    inttlx,tly,bry,brx;//t=top r=right b=bottom l=left
    tlx=tly=bry=brx=0;
    floatsuml=0;
    floatsumr=0;
    intflag=0;
 
    /**************************top edge***********************/
    for(intx=1;x<row;x++)
    {
        for(inty = 0;y<col;y++)
        {  
            if(originalImage.at<uchar>(x,y)==0)
            {
 
                flag=1;
                tly=x;
                break;
            }
 
        }
        if(flag==1)
        {
            flag=0;
            break;
        }
 
    }
    /*******************bottom edge***********************************/
    for(intx=row-1;x>0;x--)
    {
        for(inty = 0;y<col;y++)
        {
            if(originalImage.at<uchar>(x,y)==0)
            {
 
                flag=1;
                bry=x;
                break;
            }
 
        }
        if(flag==1)
        {
            flag=0;
            break;
        }
 
    }
    /*************************left edge*******************************/
 
    for(inty=0;y<col;y++)
    {
        for(intx = 0;x<row;x++)
        {
            if(originalImage.at<uchar>(x,y)==0)
            {
 
                flag=1;
                tlx=y;
                break;
            }
 
        }
        if(flag==1)
        {
            flag=0;
            break;
        }
    }
 
    /**********************right edge***********************************/
 
    for(inty=col-1;y>0;y--)
    {
        for(intx = 0;x<row;x++)
        {
            if(originalImage.at<uchar>(x,y)==0)
            {
 
                flag=1;
                brx= y;
                break;
            }
 
        }
        if(flag==1)
        {
            flag=0;
            break;
        }
    }
    intwidth = brx-tlx;
    intheight = bry-tly;
    cv::Mat crop(originalImage,cv::Rect(tlx,tly,brx-tlx,bry-tly));
    croppedImage= crop.clone();
 
}
voidconvertToPixelValueArray(cv::Mat &img,intpixelarray[])
{
    inti =0;
    for(intx=0;x<16;x++)
    {  
        for(inty=0;y<16;y++)
        {
            pixelarray[i]=(img.at<uchar>(x,y)==255)?1:0;
            i++;
 
        }
 
    }
}
string convertInt(intnumber)
{
    stringstream ss;//create a stringstream
    ss << number;//add number to the stream
    returnss.str();//return a string with the contents of the stream
}
 
voidreadFile(std::string datasetPath,intsamplesPerClass,std::string outputfile )
{
    fstream file(outputfile,ios::out);
    for(intsample = 1; sample<=samplesPerClass;sample++)
    {
        for(intdigit=0;digit<10;digit++)
        {   //creating the file path string
            std::string imagePath = datasetPath+convertInt(digit)+"\\img("+convertInt(sample)+").png";
            //reading the image
            cv::Mat img = cv::imread(imagePath,0);
            cv::Mat output;
            //Applying gaussian blur to remove any noise
            cv::GaussianBlur(img,output,cv::Size(5,5),0);
            //thresholding to get a binary image
            cv::threshold(output,output,50,255,0);
 
            //declaring mat to hold the scaled down image
            cv::Mat scaledDownImage(16,16,CV_8U,cv::Scalar(0));
            //declaring array to hold the pixel values in the memory before it written into file
            intpixelValueArray[256];
 
            //cropping the image.
            cropImage(output,output);
 
            //reducing the image dimension to 16X16
            scaleDownImage(output,scaledDownImage);
 
            //reading the pixel values.
            convertToPixelValueArray(scaledDownImage,pixelValueArray);
            //writing pixel data to file
            for(intd=0;d<256;d++){
                file<<pixelValueArray[d]<<",";
            }
            //writing the label to file
            file<<digit<<"\n";
 
        }
    }
    file.close();
}
intmain()
{
    cout<<"Reading the training set......\n";
    readFile("C:\\Users\\NITHIN\\Desktop\\OCR\\NN\\trainingset\\",305,"C:\\Users\\NITHIN\\Desktop\\OCR\\NN\\trainingset.txt");
    cout<<"Reading the test set.........\n";
    readFile("C:\\Users\\NITHIN\\Desktop\\OCR\\NN\\trainingset\\",130,"C:\\Users\\NITHIN\\Desktop\\OCR\\NN\\testset.txt");
    cout<<"operation completed";
    return0;
}









// TrainNetwork.cpp : Defines the entry point for the console application.
 
#include "opencv2/opencv.hpp"    // opencv general include file
#include "opencv2/ml/ml.hpp"          // opencv machine learning include file
#include <stdio.h>
#include <fstream>
usingnamespacestd;
/******************************************************************************/
 
#define TRAINING_SAMPLES 3050       //Number of samples in training dataset
#define ATTRIBUTES 256  //Number of pixels per sample.16X16
#define TEST_SAMPLES 1170       //Number of samples in test dataset
#define CLASSES 10                  //Number of distinct labels.
 
/********************************************************************************
This function will read the csv files(training and test dataset) and convert them
into two matrices. classes matrix have 10 columns, one column for each class label. If the label of nth row in data matrix
is, lets say 5 then the value of classes[n][5] = 1.
********************************************************************************/
voidread_dataset(char*filename, cv::Mat &data, cv::Mat &classes,  inttotal_samples)
{
 
    intlabel;
    floatpixelvalue;
    //open the file
    FILE* inputfile = fopen( filename, "r");
 
    //read each row of the csv file
   for(introw = 0; row < total_samples; row++)
   {
       //for each attribute in the row
     for(intcol = 0; col <=ATTRIBUTES; col++)
        {
            //if its the pixel value.
            if(col < ATTRIBUTES){
 
                fscanf(inputfile, "%f,", &pixelvalue);
                data.at<float>(row,col) = pixelvalue;
 
            }//if its the label
            elseif(col == ATTRIBUTES){
                //make the value of label column in that row as 1.
                fscanf(inputfile, "%i", &label);
                classes.at<float>(row,label) = 1.0;
 
            }
        }
    }
 
    fclose(inputfile);
 
}
 
/******************************************************************************/
 
intmain( intargc, char** argv )
{
    //matrix to hold the training sample
    cv::Mat training_set(TRAINING_SAMPLES,ATTRIBUTES,CV_32F);
    //matrix to hold the labels of each taining sample
    cv::Mat training_set_classifications(TRAINING_SAMPLES, CLASSES, CV_32F);
    //matric to hold the test samples
    cv::Mat test_set(TEST_SAMPLES,ATTRIBUTES,CV_32F);
    //matrix to hold the test labels.
    cv::Mat test_set_classifications(TEST_SAMPLES,CLASSES,CV_32F);
 
    //
    cv::Mat classificationResult(1, CLASSES, CV_32F);
    //load the training and test data sets.
    read_dataset("C:\\Users\\NITHIN\\Desktop\\OCR\\NN\\OCR\\training_dataset.txt", training_set, training_set_classifications, TRAINING_SAMPLES);
    read_dataset("C:\\Users\\NITHIN\\Desktop\\OCR\\NN\\OCR\\test_dataset.txt", test_set, test_set_classifications, TEST_SAMPLES);
 
        // define the structure for the neural network (MLP)
        // The neural network has 3 layers.
        // - one input node per attribute in a sample so 256 input nodes
        // - 16 hidden nodes
        // - 10 output node, one for each class.
 
        cv::Mat layers(3,1,CV_32S);
        layers.at<int>(0,0) = ATTRIBUTES;//input layer
        layers.at<int>(1,0)=16;//hidden layer
        layers.at<int>(2,0) =CLASSES;//output layer
 
        //create the neural network.
        //for more details check http://docs.opencv.org/modules/ml/doc/neural_networks.html
        CvANN_MLP nnetwork(layers, CvANN_MLP::SIGMOID_SYM,0.6,1);
 
        CvANN_MLP_TrainParams params(                                  
 
                                        // terminate the training after either 1000
                                        // iterations or a very small change in the
                                        // network wieghts below the specified value
                                        cvTermCriteria(CV_TERMCRIT_ITER+CV_TERMCRIT_EPS, 1000, 0.000001),
                                        // use backpropogation for training
                                        CvANN_MLP_TrainParams::BACKPROP,
                                        // co-efficents for backpropogation training
                                        // recommended values taken from http://docs.opencv.org/modules/ml/doc/neural_networks.html#cvann-mlp-trainparams
                                        0.1,
                                        0.1);
 
        // train the neural network (using training data)
 
        printf( "\nUsing training dataset\n");
        intiterations = nnetwork.train(training_set, training_set_classifications,cv::Mat(),cv::Mat(),params);
        printf( "Training iterations: %i\n\n", iterations);
 
        // Save the model generated into an xml file.
        CvFileStorage* storage = cvOpenFileStorage( "C:\\Users\\NITHIN\\Desktop\\OCR\\NN\\OCR1\\param.xml", 0, CV_STORAGE_WRITE );
        nnetwork.write(storage,"DigitOCR");
        cvReleaseFileStorage(&storage);
 
        // Test the generated model with the test samples.
        cv::Mat test_sample;
        //count of correct classifications
        intcorrect_class = 0;
        //count of wrong classifications
        intwrong_class = 0;
 
        //classification matrix gives the count of classes to which the samples were classified.
        intclassification_matrix[CLASSES][CLASSES]={{}};
 
        // for each sample in the test set.
        for(inttsample = 0; tsample < TEST_SAMPLES; tsample++) {
 
            // extract the sample
 
            test_sample = test_set.row(tsample);
 
            //try to predict its class
 
            nnetwork.predict(test_sample, classificationResult);
            /*The classification result matrix holds weightage  of each class.
            we take the class with the highest weightage as the resultant class */
 
            // find the class with maximum weightage.
            intmaxIndex = 0;
            floatvalue=0.0f;
            floatmaxValue=classificationResult.at<float>(0,0);
            for(intindex=1;index<CLASSES;index++)
            {   value = classificationResult.at<float>(0,index);
                if(value>maxValue)
                {   maxValue = value;
                    maxIndex=index;
 
                }
            }
 
            printf("Testing Sample %i -> class result (digit %d)\n", tsample, maxIndex);
 
            //Now compare the predicted class to the actural class. if the prediction is correct then\
            //test_set_classifications[tsample][ maxIndex] should be 1.
            //if the classification is wrong, note that.
            if(test_set_classifications.at<float>(tsample, maxIndex)!=1.0f)
            {
                // if they differ more than floating point error => wrong class
 
                wrong_class++;
 
                //find the actual label 'class_index'
                for(intclass_index=0;class_index<CLASSES;class_index++)
                {
                    if(test_set_classifications.at<float>(tsample, class_index)==1.0f)
                    {
 
                        classification_matrix[class_index][maxIndex]++;// A class_index sample was wrongly classified as maxindex.
                        break;
                    }
                }
 
            } else{
 
                // otherwise correct
 
                correct_class++;
                classification_matrix[maxIndex][maxIndex]++;
            }
        }
 
        printf( "\nResults on the testing dataset\n"
        "\tCorrect classification: %d (%g%%)\n"
        "\tWrong classifications: %d (%g%%)\n", 
        correct_class, (double) correct_class*100/TEST_SAMPLES,
        wrong_class, (double) wrong_class*100/TEST_SAMPLES);
        cout<<"   ";
        for(inti = 0; i < CLASSES; i++)
        {
            cout<< i<<"\t";
        }
        cout<<"\n";
        for(introw=0;row<CLASSES;row++)
        {cout<<row<<"  ";
            for(intcol=0;col<CLASSES;col++)
            {
                cout<<classification_matrix[row][col]<<"\t";
            }
            cout<<"\n";
        }
 
        return0;
 
}






#include "opencv2/opencv.hpp"    // opencv general include file
#include "opencv2/ml/ml.hpp"          // opencv machine learning include file
#include <stdio.h>
#include <fstream>
#define ATTRIBUTES 256  //Number of pixels per sample.16X16
#define CLASSES 10                  //Number of distinct labels.
intmain( intargc, char** argv )
{
    //read the model from the XML file and create the neural network.
    CvANN_MLP nnetwork;
    CvFileStorage* storage = cvOpenFileStorage( "C:\\Users\\NITHIN\\Desktop\\OCR\\NN\\OCR1\\param.xml", 0, CV_STORAGE_READ );
    CvFileNode *n = cvGetFileNodeByName(storage,0,"DigitOCR");
    nnetwork.read(storage,n);
    cvReleaseFileStorage(&storage);
 
    //your code here
    // ...Generate cv::Mat data(1,ATTRIBUTES,CV_32S) which will contain the pixel
    // ... data for the digit to be recognized
    // ...
 
    intmaxIndex = 0;
    cv::Mat classOut(1,CLASSES,CV_32F);
    //prediction
    nnetwork.predict(data, classOut);
    floatvalue;
    floatmaxValue=classOut.at<float>(0,0);
    for(intindex=1;index<CLASSES;index++)
    {   value = classOut.at<float>(0,index);
            if(value>maxValue)
            {   maxValue = value;
                maxIndex=index;
            }
    }
    //maxIndex is the predicted class.
 
}
